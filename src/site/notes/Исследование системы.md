---
{"dg-publish":true,"permalink":"/issledovanie-sistemy/"}
---

**Исследование** **информационной** **системы**

**ФИО:** 2022-ФГИиИБ-ИБ-1б Сорокин Дмитрий Ильич

**Исследование** **информационной** **системы**

**Содержание**

1. Введение
2. Развертывание системы
    1. Развертывание Calibre-WEB 
3. Анализ ПО
    1. Статический анализ
        1. #1
        2. #2
        3. #3
        4. #4
        5. #5
        6. #6
        7. #7
        8. #8
        9. #9
4. Заключение по статическому анализу
## **Введение**
Мною был выбран проект под названием Calibre-WEB. Calibre-WEB - это веб-приложение, которое предлагает интуитивно понятный интерфейс для просмотра, чтения и загрузки электронных книг с использованием действующей базы данных Calibre
## **Развертывание системы**
### **Развертывание Calibre-Web**
Чтобы развернуть приложение с помощью DOCKER пришлось слегка обновить файл с requirements.txt. Переходим в папку с проектом, создаем виртуальное окружение. ![IMG_1387.jpg](/img/user/IMG_1387.jpg)
![IMG_1388.jpg](/img/user/IMG_1388.jpg)
Логин и пароль берем с GitHub admin; admin123
![IMG_1389.jpg](/img/user/IMG_1389.jpg)
## **Анализ кода**
### **Статический** **анализ**
Во время работы с проектом для статического анализа мною был выбран инструмент **SEMGREP**. Для начала я авторизовался в semgrep через GitHub, загрузил проект. ![IMG_1391.png](/img/user/IMG_1391.png)

![IMG_1390.png](/img/user/IMG_1390.png)
Далее c помощью команд
> pip install semgrep
> (venv) vasiliy@localhost:~/Desktop/calibre$ SEMGREP_APP_TOKEN=fdaf5356f9941650c0f3717810892ba5a6955accfed56171d4eb94ef599a03f2 semgrep ci - авторизуемся
> semgrep scan --config auto . --sarif-output semgrep_result.sarif

![Screenshot from 2024-12-07 16-24-05.png](/img/user/Screenshot%20from%202024-12-07%2016-24-05.png)
Получаем файл results.sarif,  с использованием специального расширения, можем увидеть читабельные уязвимости 
![Screenshot from 2024-12-07 18-20-28.png](/img/user/Screenshot%20from%202024-12-07%2018-20-28.png)
Request.args.get("state", "[]") берет данные из HTTP-запроса (URL-параметров). Это данные, которые пользователь может подменить. Json.loads() принимает строку и преобразует ее в Python-объект. Если злоумышленник передаст вредоносный JSON, это может привести к несанкционированной обработке данных, сбою программы или внедрению непредвиденных структур. Отсюда вытекают DoS, инъекции и логические ошибки
![Screenshot from 2024-12-07 18-36-04.png](/img/user/Screenshot%20from%202024-12-07%2018-36-04.png)
Тут Semgrep обнаружил, что в коде хранится API-ключ в явном виде. Это небезопасно, поскольку ключ может быть случайно опубликован (например, при размещении репозитория в публичном доступе), что позволит злоумышленникам использовать этот ключ для доступа к внешним сервисам. **Неавторизованный доступ, лимиты API, потеря репутации:**
![7HGFj3nqJzxihH59xYuA7FGgo0g-960.jpg](/img/user/7HGFj3nqJzxihH59xYuA7FGgo0g-960.jpg):

![Screenshot from 2024-12-07 18-36-19.png](/img/user/Screenshot%20from%202024-12-07%2018-36-19.png)
InnerHTML используется для вставки HTML-кода в DOM. В данном случае, HTML-структура (включая <ul>, <li>, и <marquee>) добавляется на страницу, а item.innerHTML представляет собой внутреннее содержимое какого-либо элемента item, которое вставляется как часть нового HTML-кода.
Риск XSS: Если значение item.innerHTML может быть модифицировано или контролироваться пользователем (например, с помощью данных из формы или URL-параметров), это может привести к внедрению вредоносного JavaScript-кода в контекст страницы, что является классическим примером уязвимости Cross-Site Scripting (XSS).
XSS (Cross-Site Scripting) — это уязвимость, позволяющая атакующему вставить вредоносный JavaScript-код в страницу, которая затем выполняется в браузере жертвы.



Уязвимость detect-insecure-websocket относится к небезопасному использованию WebSocket-соединений. WebSocket — это протокол, позволяющий устанавливать постоянное двустороннее соединение между клиентом и сервером. Он широко используется в приложениях реального времени, таких как чаты, игры или финансовые приложения.

Когда WebSocket-соединение используется через нешифрованное соединение (ws://), данные передаются в открытом виде, что подвергает их риску перехвата и модификации злоумышленниками. 
![Screenshot from 2024-12-07 18-45-07.png](/img/user/Screenshot%20from%202024-12-07%2018-45-07.png)
Уязвимость sqlalchemy-flask связана с неправильным использованием SQLAlchemy в приложениях Flask, что может привести к проблемам с безопасностью, таким как SQL инъекции или недостаточная защита данных. SQLAlchemy — это популярная библиотека ORM (Object Relational Mapper) для работы с базой данных в Python, а Flask — это веб-фреймворк, который часто используется для создания веб-приложений.

Основная угроза здесь заключается в неправильном или небезопасном использовании SQL-запросов, особенно при динамическом формировании запросов с пользовательскими данными.
В коде выше значение user_id берется напрямую из запроса и вставляется в SQL-запрос без экранирования.
