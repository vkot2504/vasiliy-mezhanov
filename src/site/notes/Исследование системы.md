---
{"dg-publish":true,"permalink":"/issledovanie-sistemy/"}
---

**Исследование** **информационной** **системы**

**ФИО:** 2022-ФГИиИБ-ИБ-1б Межанов Василий Сергеевич

**Исследование** **информационной** **системы**

**Содержание**

1. Введение
2. Развертывание системы
    1. Развертывание Calibre-WEB 
3. Анализ ПО
    1. Статический анализ
        1. #1
        2. #2
        3. #3
        4. #4
        5. #5
        6. #6
    2. Проверка зависимостей

## **Введение**
Мною был выбран проект под названием Calibre-WEB. Calibre-WEB - это веб-приложение, которое предлагает интуитивно понятный интерфейс для просмотра, чтения и загрузки электронных книг с использованием действующей базы данных Calibre
## **Развертывание системы**
### **Развертывание Calibre-Web**
Чтобы развернуть приложение с помощью DOCKER пришлось слегка обновить файл с requirements.txt. Переходим в папку с проектом, создаем виртуальное окружение. ![IMG_1387.jpg](/img/user/IMG_1387.jpg)
![5417855864288703376.jpg](/img/user/5417855864288703376.jpg)
Переходим в LocalHost
![IMG_1388.jpg](/img/user/IMG_1388.jpg)
Логин и пароль берем с GitHub admin; admin123
![IMG_1389.jpg](/img/user/IMG_1389.jpg)
## **Анализ кода**
### **Статический** **анализ**
Во время работы с проектом для статического анализа мною был выбран инструмент **SEMGREP**. Для начала я авторизовался в semgrep через GitHub, загрузил проект. ![IMG_1391.png](/img/user/IMG_1391.png)

![IMG_1390.png](/img/user/IMG_1390.png)
Далее c помощью команд
> pip install semgrep
> (venv) vasiliy@localhost:~/Desktop/calibre$ SEMGREP_APP_TOKEN=fdaf5356f9941650c0f3717810892ba5a6955accfed56171d4eb94ef599a03f2 semgrep ci - авторизуемся
> semgrep scan --config auto . --sarif-output semgrep_result.sarif

![Screenshot from 2024-12-07 16-24-05.png](/img/user/Screenshot%20from%202024-12-07%2016-24-05.png)
Получаем файл results.sarif,  с использованием специального расширения, можем увидеть читабельные уязвимости 
### **#1**
![Screenshot from 2024-12-07 18-20-28.png](/img/user/Screenshot%20from%202024-12-07%2018-20-28.png)
Request.args.get("state") берет данные из HTTP-запроса (URL-параметров). Это данные, которые пользователь может подменить. Json.loads() принимает строку и преобразует ее в Python-объект. Если злоумышленник передаст вредоносный JSON, это может привести к несанкционированной обработке данных, сбою программы или внедрению непредвиденных структур. Отсюда вытекают DoS, инъекции и логические ошибки

Попытка запустить код через flask и уже проанализировать прошла без успеха, так как столкнулся с ошибкой access denied 

Но я запустил локально код, чтобы протестировать логику на уровне Python 
![2024-12-28 13.00.51.jpg](/img/user/2024-12-28%2013.00.51.jpg)
Я создал новый файл. В этом файле разместил только ту часть логики, которая обрабатывает параметр state с помощью json.loads и проверки на корректность данных.
![2024-12-28 13.03.01 1.jpg](/img/user/2024-12-28%2013.03.01%201.jpg)
Результаты тестов:
Valid state (валидное состояние):
Я передал список [1, 2, 3], и результат был правильным:
Processed state: [1, 2, 3]. Это значит, что код корректно обрабатывает валидные данные.

Invalid JSON (некорректный JSON):
Я передал строку '{invalid_json}', которая не является валидным JSON, и результат:
Error processing state: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)
Это подтверждает, что код корректно ловит ошибку при некорректном JSON. Ошибка указывает на то, что строка не является валидным JSON.
Я передал список с элементами разных типов, например, [1, "two", 3]. Результат:
Error processing state: All items in state must be integers.
Это подтверждает, что код правильно проверяет, что все элементы в списке должны быть целыми числами.

Я передал очень длинный список (от 1 до 100), и результат был правильным:

Processed state: [1, 2, 3, ..., 100]

Это подтверждает, что код корректно обрабатывает длинные списки, обрезая их до максимальной длины в 100 элементов.

Давайте протестируем другие аспекты, которые могут быть важными для проверки безопасности или стабильности кода. Вот несколько дополнительных моментов, которые мы можем протестировать:
1. Проверка на SQL-инъекции
SQL-инъекции — это классическая уязвимость, когда злоумышленник пытается изменить запрос, вставив в параметры запроса SQL код. Нам нужно проверить, как код обрабатывает параметры запроса и безопасен ли он.
Мы можем попробовать передать в запрос параметры, содержащие потенциально опасные SQL-инъекции.
Попробуем передать state с SQL-инъекцией:
test_state('[1, 2, 3, 4, 5]; DROP TABLE users;--]')
Что мы ожидаем:
Код должен корректно обработать такие данные, избегая выполнения непреднамеренных запросов.
2. Проверка на XSS (межсайтовый скриптинг)
XSS-уязвимости могут возникать, когда данные, введенные пользователем, вставляются обратно в HTML-код без надлежащей очистки. Попробуем передать в запрос данные, которые содержат JavaScript-код, чтобы проверить, может ли сервер или приложение выполнить этот код.
Попробуем передать JavaScript-код через параметр state или другие параметры запроса.
Передаем вредоносный JavaScript-код:

test_state('[1, 2, <script>alert("XSS")</script>]')

Что мы ожидаем:

Код должен правильно обработать такие данные и не выполнить вредоносный скрипт.



Реализация тестов
![2024-12-28 13.06.50.jpg](/img/user/2024-12-28%2013.06.50.jpg)
![2024-12-28 13.07.13.jpg](/img/user/2024-12-28%2013.07.13.jpg)
Testing SQL Injection:
Мы получили ошибку:

Error processing state: Extra data: line 1 column 16 (char 15)

Это произошло, потому что мы передали в state данные, которые не соответствуют ожидаемому формату JSON. Пример "[1, 2, 3, 4, 5]; DROP TABLE users;--]" содержит некорректный JSON (наличие SQL-кода), что и вызвало ошибку. Это хороший признак того, что  система не выполняет SQL-код.

Мы получили ошибку:

Error processing state: Expecting value: line 1 column 8 (char 7)

Это также связано с некорректным JSON, так как строка "[1, 2, <script>alert('XSS')</script>]" не является валидным JSON (из-за включения HTML/JavaScript). Пример XSS не был интерпретирован как код. Это подтверждает, что сервер корректно обрабатывает нежелательные данные, и JavaScript не был выполнен.

Мы получили ошибку:

Error processing state: All items in state must be integers.

Это правильное поведение. Ошибка возникла из-за того, что список "[1, 'two', 3]" содержит строку "two", а не целое число. Это подтверждает, что ваш код проверяет типы данных и отклоняет ненадежные данные.
### **#2**
![Screenshot from 2024-12-07 18-36-04.png](/img/user/Screenshot%20from%202024-12-07%2018-36-04.png)
Тут Semgrep обнаружил, что в коде хранится API-ключ в явном виде. Это небезопасно, поскольку ключ может быть случайно опубликован (например, при размещении репозитория в публичном доступе), что позволит злоумышленникам использовать этот ключ для доступа к внешним сервисам. **Неавторизованный доступ, лимиты API, потеря репутации:**

![7HGFj3nqJzxihH59xYuA7FGgo0g-960.jpg](/img/user/7HGFj3nqJzxihH59xYuA7FGgo0g-960.jpg)
API ключ в ComicVine используется для аутентификации и авторизации запросов, направленных к их API. Когда вы отправляете запросы к API ComicVine, ключ помогает серверу идентифицировать ваше приложение и убедиться, что оно имеет разрешение на доступ к данным.
### **#3**

![Screenshot from 2024-12-07 18-36-19.png](/img/user/Screenshot%20from%202024-12-07%2018-36-19.png)
InnerHTML используется для вставки HTML-кода в DOM. В данном случае, HTML-структура (включая ul, li, и marquee) добавляется на страницу, а item.innerHTML представляет собой внутреннее содержимое какого-либо элемента item, которое вставляется как часть нового HTML-кода.
Риск XSS: Если значение item.innerHTML может быть модифицировано или контролироваться пользователем (например, с помощью данных из формы или URL-параметров), это может привести к внедрению вредоносного JavaScript-кода в контекст страницы, что является классическим примером уязвимости Cross-Site Scripting (XSS).
XSS (Cross-Site Scripting) — это уязвимость, позволяющая атакующему вставить вредоносный JavaScript-код в страницу, которая затем выполняется в браузере жертвы.

Этот код представляет собой фрагмент для работы с аудиоплеером, использующим библиотеку SoundManager 2 (SM2), которая позволяет взаимодействовать с аудиофайлами, используя HTML5 или Flash (если необходимо). Этот плеер поддерживает различные функции, такие как воспроизведение, пауза, отображение прогресса и т. д.
Суть проблемы заключается в том, что item.innerHTML может содержать данные, введённые пользователем, и если эти данные не очищены, они могут содержать вредоносный JavaScript-код, который затем будет выполнен в браузере другого пользователя.
Если  всё-таки нужно вставить HTML, требуется очистить данные, чтобы убедиться, что они не содержат вредоносных скриптов. Можно использовать сторонние библиотеки для безопасного парсинга и очистки HTML, например DOMPurify.
```js 
var cleanHTML = DOMPurify.sanitize(item.innerHTML);
dom.playlistTarget.innerHTML = '<ul class="sm2-playlist-bd"><li><marquee>' + cleanHTML + '</marquee></li></ul>';
``` 
DOMPurify очищает HTML от любых вредоносных элементов, таких как script, что делает вставку безопасной.

### **#4**
![Screenshot from 2024-12-07 18-38-44 2.png](/img/user/Screenshot%20from%202024-12-07%2018-38-44%202.png)
Уязвимость detect-insecure-websocket относится к небезопасному использованию WebSocket-соединений. WebSocket — это протокол, позволяющий устанавливать постоянное двустороннее соединение между клиентом и сервером. Он широко используется в приложениях реального времени, таких как чаты, игры или финансовые приложения.
Когда WebSocket-соединение используется через нешифрованное соединение (ws://), данные передаются в открытом виде, что подвергает их риску перехвата и модификации злоумышленниками. 
### **#5**
![Screenshot from 2024-12-07 18-42-56.png](/img/user/Screenshot%20from%202024-12-07%2018-42-56.png)
Уязвимость sqlalchemy-flask связана с неправильным использованием SQLAlchemy в приложениях Flask, что может привести к проблемам с безопасностью, таким как SQL инъекции или недостаточная защита данных. SQLAlchemy — это популярная библиотека ORM (Object Relational Mapper) для работы с базой данных в Python, а Flask — это веб-фреймворк, который часто используется для создания веб-приложений.

Основная угроза здесь заключается в неправильном или небезопасном использовании SQL-запросов, особенно при динамическом формировании запросов с пользовательскими данными.
Необработанный ввод в запрос SQL:
 В коде используется строка text(sort + " " + order), которая может включать данные из пользовательского ввода (например, сортировку). Этот ввод не проверяется должным образом, что создает возможность для SQL-инъекции.
 Как решение проблемы - использование order_by с проверкой допустимых значений: Вместо того чтобы напрямую вставлять значение сортировки в запрос, можно заранее проверить, является ли параметр сортировки допустимым, и использовать его в рамках допустимых значений.
### **#6**
![Screenshot from 2024-12-07 18-45-07 3.png](/img/user/Screenshot%20from%202024-12-07%2018-45-07%203.png)
Уязвимость tainted-path-traversal-stdlib-flask связана с использованием path traversal в приложении на Flask. Эта уязвимость возникает, когда приложение позволяет пользователю манипулировать путями файлов, передавая неподтвержденные или небезопасные пути файлов в функции работы с файлами, такие как copyfile, open или другие файловые операции.
Злоумышленник может использовать символы ../ для перехода в директории, которые находятся за пределами допустимой области файловой системы. Это может привести к доступу или изменению критичных файлов системы

## **Проверка зависимостей**
Чтобы была возможность проанализировать зависимости требуется воспользоваться CycloneDX, сформировать SBOM файл. 
> npm install -g @cyclonedx/cdxgen

Конечно же, проблема с версией node возникла. 
![Screenshot from 2024-12-12 22-56-03.png](/img/user/Screenshot%20from%202024-12-12%2022-56-03.png)
![Screenshot from 2024-12-12 22-56-11.png](/img/user/Screenshot%20from%202024-12-12%2022-56-11.png)
![Screenshot from 2024-12-12 23-35-07.png](/img/user/Screenshot%20from%202024-12-12%2023-35-07.png)
Сгенерировал файл SBOM , открыл 
![Screenshot from 2024-12-13 00-29-03.png](/img/user/Screenshot%20from%202024-12-13%2000-29-03.png)
Все упирается лишь в устаревшие версии. 
![5418150971491610995.jpg](/img/user/5418150971491610995.jpg)
